import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { User } from '../../app/models/models';
import { RootState } from '../../app/store';
import { AuthenticateParameters, AuthService, CreateUserParameters } from '../../services/auth.service';
import { TokenService } from '../../services/token.service';
import { DoLoginResponse, DoLogoutResponse, DoSignupResponse } from './authDto';

type AuthStatus = 'logged-in' | 'logging-in' | 'login-failed' | 'logged-out' | 'signing-up' | 'signup-failed' | 'signup-complete';

export interface AuthState {
  status: AuthStatus;
  loggedInUsername: string;
  signedUpUsername: string;
  userSessionId: string;
  currentUser: User | undefined;
}

const initialState: AuthState = {
  status: 'logged-out',
  loggedInUsername: '',
  signedUpUsername: '',
  userSessionId: '',
  currentUser: undefined,
};


export interface DoLoginResult {
  response?: DoLoginResponse;
  newStatus: AuthStatus;
}


// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const signupAsync = createAsyncThunk(
  'auth/signup',
  async (createUserParameters: CreateUserParameters): Promise<DoSignupResponse> => {
    const response = await AuthService.createUser(createUserParameters);
    return response as DoSignupResponse;
  }
);

export const loginAsync = createAsyncThunk(
  'auth/login',
  async (loginParameters: AuthenticateParameters): Promise<DoLoginResponse> => {
    const response = await AuthService.authenticate(loginParameters) as DoLoginResponse;
    return response;
  }
);

export const logoutAsync = createAsyncThunk(
  'auth/logout',
  async (): Promise<DoLogoutResponse> => {
    const response = await AuthService.logout();
    console.log(response);
    return response as DoLogoutResponse;
  }
);


export const authSlice = createSlice({
  name: 'auth',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: { },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(signupAsync.pending, (state) => {
        console.log("SIGNING UP");
        state.status = 'signing-up';
      })
      .addCase(signupAsync.fulfilled, (state, action) => {
        console.log("SIGN UP COMPLETE");
        console.log(action);
        state.signedUpUsername = action.payload.finalUserName;
        state.status = 'signup-complete';
      })
      .addCase(signupAsync.rejected, (state, action) => {
        console.log("SIGN UP ERROR");
        console.log(action);
        state.status = 'signup-failed';
      })
      
      .addCase(loginAsync.pending, (state) => {
        console.log("LOGGING IN");
        state.status = 'logging-in';
      })
      .addCase(loginAsync.fulfilled, (state, action) => {
        if (action.payload.success) {
          TokenService.saveAuthToken(action.payload.token);
          state.loggedInUsername = action.payload.loggedInUsername;
          state.status = 'logged-in';
          state.currentUser = {
            id: "123",
            name: action.payload.loggedInScreenName,
          };
        } else {
          TokenService.clearAuthToken();
          state.status = 'login-failed';
        }
      })
      .addCase(loginAsync.rejected, (state) => {
        TokenService.clearAuthToken();
        state.status = 'login-failed';
      })

      // .addCase(logoutAsync.pending, (state) => {
      //   console.log("LOGGING IN");
      //   state.state = 'logging-in';
      // })
      .addCase(logoutAsync.fulfilled, (state) => {
        TokenService.clearAuthToken();
        state.status = 'logged-out';
        state.loggedInUsername = "";
      })
      .addCase(logoutAsync.rejected, (state) => {
        TokenService.clearAuthToken();
        state.status = 'logged-out';
        state.loggedInUsername = "";
      })

      ;
  },
});

export const selectAuth = (state: RootState) => state.auth;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd = (amount: number): AppThunk => (
//   dispatch,
//   getState
// ) => {
//   const currentValue = selectCount(getState());
//   if (currentValue % 2 === 1) {
//     dispatch(incrementByAmount(amount));
//   }
// };

export default authSlice.reducer;
